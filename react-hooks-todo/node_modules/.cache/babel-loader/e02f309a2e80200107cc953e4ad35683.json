{"ast":null,"code":"var _jsxFileName = \"E:\\\\App Development\\\\React\\\\react-projects\\\\react-hooks-todo\\\\src\\\\components\\\\Ingredients\\\\Ingredients.js\",\n    _s = $RefreshSig$();\n\nimport React, { useReducer, useEffect, useCallback, useMemo } from 'react';\nimport IngredientForm from './IngredientForm';\nimport Search from './Search';\nimport IngredientList from './IngredientList';\nimport ErrorModal from '../UI/ErrorModal';\nimport useHttp from '../../hooks/http'; //reducer takes in 2 arguments, the old state and an action\n\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nconst ingredientReducer = (currentIngredients, action) => {\n  switch (action.type) {\n    case 'SET':\n      return action.ingredients;\n    //our new ingredients, SET should override current ingredients with a new list/array. Hence the ingredients property which should be an array of ingredients which will replace the old state\n\n    case 'ADD':\n      return [...currentIngredients, action.ingredient];\n\n    case 'DELETE':\n      return currentIngredients.filter(ing => ing.id !== action.id);\n\n    default:\n      throw new Error('Should not get here');\n  }\n}; //useCallback allows you to wrap a function that takes in two arguments, it caches your function for you so it survives rerender cycles\n// Line 21 when user submits a form on ingredients form, it will pass up the value to addIngredientHandler\n\n\nconst Ingredients = () => {\n  _s();\n\n  //useReducer returns something, that something is an array but with state (userIngredients). Second argument is something to set our userIngredients, \n  //which we are using in our reducer function (ingredientReducer)\n  //we'll call it dispatch because dispatch will be a function that call to dispatch these actions later in ingredientReducer.\n  //userReducer takes a first argument our reducer function and takes an optional second argument, starting state which we will set an an empty array\n  const [userIngredients, dispatch] = useReducer(ingredientReducer, []); // const [userIngredients, setUserIngredients] = useState([]);\n\n  const {\n    isLoading,\n    data,\n    error,\n    sendRequest,\n    requestExtra\n  } = useHttp();\n  useEffect(() => {\n    if (requestExtra) {\n      dispatch({\n        type: 'DELETE',\n        id: requestExtra\n      });\n    } else {\n      dispatch({\n        type: 'ADD',\n        ingredient: {\n          id: data.name,\n          ...requestExtra\n        }\n      });\n    }\n  }, [data, requestExtra]); //connect to search component, so when the user uses the filter/useEffect, it sends the data to this method\n\n  const filterIngredientsHandler = useCallback(filterIngredients => {\n    //dispatch an action, which can be anything but often its an object with a type property describing what action we want to do. And it needs an ingredients property to work properly\n    //with this we're updating our userIngredients\n    dispatch({\n      type: 'SET',\n      ingredients: filterIngredients\n    });\n  }, []); //set user ingredient should now have a id, title, and amount object\n  //user adds an ingredient, it will update the ingredients array on line 10 then to 25\n\n  const addIngredientHandler = useCallback(ingredient => {\n    sendRequest('https://react-hooks-update-77b76-default-rtdb.firebaseio.com/ingredients.json', 'POST', JSON.stringify(ingredient), ingredient); // dispatchHttp({type: 'SEND'});\n    // setIsLoading(true);\n    // console.log(\"ingredient: \", ingredient);\n    // //send HTTP request, browser function, not a react function\n    // //fetch will return a promise, which will resolve once this request is successfully sent or fails\n    // fetch('https://react-hooks-update-77b76-default-rtdb.firebaseio.com/ingredients.json', {\n    //   method: 'POST',\n    //   body: JSON.stringify({ingredient}),\n    //   headers: { 'Content-Type': 'application/json' }\n    // }).then(response => {\n    //     //execute after response\n    //     // dispatchHttp({type: 'RESPONSE'});\n    //     // setIsLoading(false);\n    //   return response.json(); //body of the response, will convert JSON to normal JS code. This returns a promise so we should return it then run another then function.\n    // }).then (responseData => {\n    //   //only set the ingredien when the request is done as well as when the response parsing is finished\n    //   // setUserIngredients(previousIngredient => [...previousIngredient,\n    //   //   { id:responseData.name, ...ingredient }]);  \n    //   dispatch({type: 'ADD', ingredient: { id:responseData.name, ...ingredient }})\n    //     //response.name is a unique id generated by firebase, name will be different for other APIs\n    // });\n  }, []);\n  const removeIngredientHandler = useCallback(ingredientId => {\n    sendRequest(`https://react-hooks-update-77b76-default-rtdb.firebaseio.com/ingredients/${ingredientId}.json`, 'DELETE', null, ingredientId);\n  }, [sendRequest]);\n  const clearError = useCallback(() => {// dispatchHttp({type: 'CLEAR'});\n    // setError(null); \n  }, []);\n  const ingredientList = useMemo(() => {\n    return /*#__PURE__*/_jsxDEV(IngredientList, {\n      ingredients: userIngredients,\n      onRemoveItem: removeIngredientHandler\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 98,\n      columnNumber: 7\n    }, this);\n  }, [userIngredients, removeIngredientHandler]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"App\",\n    children: [error && /*#__PURE__*/_jsxDEV(ErrorModal, {\n      onClose: clearError,\n      children: error\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 104,\n      columnNumber: 17\n    }, this), /*#__PURE__*/_jsxDEV(IngredientForm, {\n      onAddIngredient: addIngredientHandler,\n      loading: isLoading\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 106,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"section\", {\n      children: [/*#__PURE__*/_jsxDEV(Search, {\n        onLoadIngredients: filterIngredientsHandler\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 111,\n        columnNumber: 9\n      }, this), ingredientList]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 110,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 103,\n    columnNumber: 5\n  }, this);\n};\n\n_s(Ingredients, \"oFVihQ3VfpW+3JOm359ie/mWJ9I=\", false, function () {\n  return [useHttp];\n});\n\n_c = Ingredients;\nexport default Ingredients;\n\nvar _c;\n\n$RefreshReg$(_c, \"Ingredients\");","map":{"version":3,"sources":["E:/App Development/React/react-projects/react-hooks-todo/src/components/Ingredients/Ingredients.js"],"names":["React","useReducer","useEffect","useCallback","useMemo","IngredientForm","Search","IngredientList","ErrorModal","useHttp","ingredientReducer","currentIngredients","action","type","ingredients","ingredient","filter","ing","id","Error","Ingredients","userIngredients","dispatch","isLoading","data","error","sendRequest","requestExtra","name","filterIngredientsHandler","filterIngredients","addIngredientHandler","JSON","stringify","removeIngredientHandler","ingredientId","clearError","ingredientList"],"mappings":"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","sourcesContent":["import React, { useReducer, useEffect, useCallback, useMemo } from 'react';\n\nimport IngredientForm from './IngredientForm';\nimport Search from './Search';\nimport IngredientList from './IngredientList';\nimport ErrorModal from '../UI/ErrorModal';\nimport useHttp from '../../hooks/http';\n\n//reducer takes in 2 arguments, the old state and an action\nconst ingredientReducer = (currentIngredients, action) => {\n  switch (action.type) {\n    case 'SET':\n      return action.ingredients; //our new ingredients, SET should override current ingredients with a new list/array. Hence the ingredients property which should be an array of ingredients which will replace the old state\n    case 'ADD':\n      return [...currentIngredients, action.ingredient];\n    case 'DELETE':\n      return currentIngredients.filter(ing => ing.id !== action.id);\n    default:\n      throw new Error('Should not get here');\n  }\n}\n\n//useCallback allows you to wrap a function that takes in two arguments, it caches your function for you so it survives rerender cycles\n// Line 21 when user submits a form on ingredients form, it will pass up the value to addIngredientHandler\nconst Ingredients = () => {\n  //useReducer returns something, that something is an array but with state (userIngredients). Second argument is something to set our userIngredients, \n  //which we are using in our reducer function (ingredientReducer)\n  //we'll call it dispatch because dispatch will be a function that call to dispatch these actions later in ingredientReducer.\n  //userReducer takes a first argument our reducer function and takes an optional second argument, starting state which we will set an an empty array\n  const [userIngredients, dispatch] = useReducer(ingredientReducer, []);\n  // const [userIngredients, setUserIngredients] = useState([]);\n  const { isLoading, data, error, sendRequest, requestExtra } = useHttp();\n\n  useEffect(() => {\n    if (requestExtra) {\n      dispatch({type: 'DELETE', id: requestExtra})\n    } else {\n      dispatch({type: 'ADD', ingredient: { id:data.name, ...requestExtra }})\n    }\n\n  }, [data, requestExtra]);\n\n  //connect to search component, so when the user uses the filter/useEffect, it sends the data to this method\n  const filterIngredientsHandler = useCallback(filterIngredients => {\n    //dispatch an action, which can be anything but often its an object with a type property describing what action we want to do. And it needs an ingredients property to work properly\n    //with this we're updating our userIngredients\n    dispatch({type: 'SET', ingredients: filterIngredients})\n  }, []);\n\n  //set user ingredient should now have a id, title, and amount object\n  //user adds an ingredient, it will update the ingredients array on line 10 then to 25\n  const addIngredientHandler = useCallback(ingredient => {\n    sendRequest(\n      'https://react-hooks-update-77b76-default-rtdb.firebaseio.com/ingredients.json', \n      'POST', \n      JSON.stringify(ingredient),\n      ingredient\n    )\n\n    // dispatchHttp({type: 'SEND'});\n    // setIsLoading(true);\n    // console.log(\"ingredient: \", ingredient);\n    // //send HTTP request, browser function, not a react function\n    // //fetch will return a promise, which will resolve once this request is successfully sent or fails\n    // fetch('https://react-hooks-update-77b76-default-rtdb.firebaseio.com/ingredients.json', {\n    //   method: 'POST',\n    //   body: JSON.stringify({ingredient}),\n    //   headers: { 'Content-Type': 'application/json' }\n    // }).then(response => {\n    //     //execute after response\n    //     // dispatchHttp({type: 'RESPONSE'});\n    //     // setIsLoading(false);\n    //   return response.json(); //body of the response, will convert JSON to normal JS code. This returns a promise so we should return it then run another then function.\n    // }).then (responseData => {\n    //   //only set the ingredien when the request is done as well as when the response parsing is finished\n    //   // setUserIngredients(previousIngredient => [...previousIngredient,\n    //   //   { id:responseData.name, ...ingredient }]);  \n    //   dispatch({type: 'ADD', ingredient: { id:responseData.name, ...ingredient }})\n    //     //response.name is a unique id generated by firebase, name will be different for other APIs\n    // });\n  }, []);\n\n  const removeIngredientHandler = useCallback(ingredientId => {\n    sendRequest(`https://react-hooks-update-77b76-default-rtdb.firebaseio.com/ingredients/${ingredientId}.json`, \n    'DELETE',\n    null,\n    ingredientId\n    );\n  }, [sendRequest]);\n\n  const clearError= useCallback(() => {\n    // dispatchHttp({type: 'CLEAR'});\n    // setError(null); \n  }, []);\n  \n  const ingredientList = useMemo(() => {\n    return (        \n      <IngredientList ingredients={userIngredients} onRemoveItem={removeIngredientHandler}/>\n    )\n  }, [userIngredients, removeIngredientHandler])\n\n  return (\n    <div className=\"App\">\n      {error && <ErrorModal onClose={clearError}>{error}</ErrorModal>}\n\n      <IngredientForm \n        onAddIngredient={addIngredientHandler} \n        loading={isLoading}/>\n\n      <section>\n        <Search onLoadIngredients={filterIngredientsHandler}/>\n        {ingredientList}\n      </section>\n    </div>\n  );\n}\n\nexport default Ingredients;\n"]},"metadata":{},"sourceType":"module"}