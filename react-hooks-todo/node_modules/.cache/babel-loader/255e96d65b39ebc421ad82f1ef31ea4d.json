{"ast":null,"code":"var _jsxFileName = \"E:\\\\App Development\\\\React\\\\react-projects\\\\react-hooks-todo\\\\src\\\\components\\\\Ingredients\\\\Ingredients.js\",\n    _s = $RefreshSig$();\n\nimport React, { useReducer, useEffect, useCallback, useMemo } from 'react';\nimport IngredientForm from './IngredientForm';\nimport Search from './Search';\nimport IngredientList from './IngredientList';\nimport ErrorModal from '../UI/ErrorModal'; //reducer takes in 2 arguments, the old state and an action\n\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nconst ingredientReducer = (currentIngredients, action) => {\n  switch (action.type) {\n    case 'SET':\n      return action.ingredients;\n    //our new ingredients, SET should override current ingredients with a new list/array. Hence the ingredients property which should be an array of ingredients which will replace the old state\n\n    case 'ADD':\n      return [...currentIngredients, action.ingredient];\n\n    case 'DELETE':\n      return currentIngredients.filter(ing => ing.id !== action.id);\n\n    default:\n      throw new Error('Should not get here');\n  }\n}; //useCallback allows you to wrap a function that takes in two arguments, it caches your function for you so it survives rerender cycles\n// Line 21 when user submits a form on ingredients form, it will pass up the value to addIngredientHandler\n\n\nconst Ingredients = () => {\n  _s();\n\n  //useReducer returns something, that something is an array but with state (userIngredients). Second argument is something to set our userIngredients, \n  //which we are using in our reducer function (ingredientReducer)\n  //we'll call it dispatch because dispatch will be a function that call to dispatch these actions later in ingredientReducer.\n  //userReducer takes a first argument our reducer function and takes an optional second argument, starting state which we will set an an empty array\n  const [userIngredients, dispatch] = useReducer(ingredientReducer, []); // const [userIngredients, setUserIngredients] = useState([]);\n\n  const [httpState, dispatchHttp] = useReducer(httpReducer, {\n    isLoading: false,\n    error: null\n  }); // const [isLoading, setIsLoading] = useState(false);\n  // const [error, setError] = useState();\n\n  useEffect(() => {\n    console.log('RENDERING INGREDIENTS', userIngredients);\n  }, [userIngredients]); //connect to search component, so when the user uses the filter/useEffect, it sends the data to this method\n\n  const filterIngredientsHandler = useCallback(filterIngredients => {\n    //dispatch an action, which can be anything but often its an object with a type property describing what action we want to do. And it needs an ingredients property to work properly\n    //with this we're updating our userIngredients\n    dispatch({\n      type: 'SET',\n      ingredients: filterIngredients\n    });\n  }, []); //set user ingredient should now have a id, title, and amount object\n  //user adds an ingredient, it will update the ingredients array on line 10 then to 25\n\n  const addIngredientHandler = useCallback(ingredient => {\n    dispatchHttp({\n      type: 'SEND'\n    }); // setIsLoading(true);\n\n    console.log(\"ingredient: \", ingredient); //send HTTP request, browser function, not a react function\n    //fetch will return a promise, which will resolve once this request is successfully sent or fails\n\n    fetch('https://react-hooks-update-77b76-default-rtdb.firebaseio.com/ingredients.json', {\n      method: 'POST',\n      body: JSON.stringify({\n        ingredient\n      }),\n      headers: {\n        'Content-Type': 'application/json'\n      }\n    }).then(response => {\n      //execute after response\n      dispatchHttp({\n        type: 'RESPONSE'\n      }); // setIsLoading(false);\n\n      return response.json(); //body of the response, will convert JSON to normal JS code. This returns a promise so we should return it then run another then function.\n    }).then(responseData => {\n      //only set the ingredien when the request is done as well as when the response parsing is finished\n      // setUserIngredients(previousIngredient => [...previousIngredient,\n      //   { id:responseData.name, ...ingredient }]);  \n      dispatch({\n        type: 'ADD',\n        ingredient: {\n          id: responseData.name,\n          ...ingredient\n        }\n      }); //response.name is a unique id generated by firebase, name will be different for other APIs\n    });\n  }, []);\n  const removeIngredientHandler = useCallback(ingredientId => {\n    console.log('removeIngredient: ', ingredientId);\n    dispatchHttp({\n      type: 'SEND'\n    }); // setIsLoading(true);\n\n    fetch(`https://react-hooks-update-77b76-default-rtdb.firebaseio.com/ingredients/${ingredientId}.json`, {\n      method: 'DELETE'\n    }).then(response => {\n      dispatchHttp({\n        type: 'RESPONSE'\n      }); // setIsLoading(false);\n      // setUserIngredients(previousIngredient => {\n      //   previousIngredient.filter(ingredient => ingredient.id !== ingredientId);\n      // });\n\n      dispatch({\n        type: 'DELETE',\n        id: ingredientId\n      });\n    }).catch(error => {\n      dispatchHttp({\n        type: 'ERROR',\n        errorMessage: 'Something went wrong'\n      }); // setError(error.message);\n      // setIsLoading(false);\n    });\n  }, []);\n  const clearError = useCallback(() => {\n    dispatchHttp({\n      type: 'CLEAR'\n    }); // setError(null); \n  }, []);\n  const ingredientList = useMemo(() => {\n    return /*#__PURE__*/_jsxDEV(IngredientList, {\n      ingredients: userIngredients,\n      onRemoveItem: removeIngredientHandler\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 104,\n      columnNumber: 7\n    }, this);\n  }, [userIngredients, removeIngredientHandler]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"App\",\n    children: [httpState.error && /*#__PURE__*/_jsxDEV(ErrorModal, {\n      onClose: clearError,\n      children: httpState.error\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 110,\n      columnNumber: 27\n    }, this), /*#__PURE__*/_jsxDEV(IngredientForm, {\n      onAddIngredient: addIngredientHandler,\n      loading: httpState.isLoading\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 112,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"section\", {\n      children: [/*#__PURE__*/_jsxDEV(Search, {\n        onLoadIngredients: filterIngredientsHandler\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 117,\n        columnNumber: 9\n      }, this), ingredientList]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 116,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 109,\n    columnNumber: 5\n  }, this);\n};\n\n_s(Ingredients, \"T4V3JFjPsn6qByl4YOJd3TLR1E0=\");\n\n_c = Ingredients;\nexport default Ingredients;\n\nvar _c;\n\n$RefreshReg$(_c, \"Ingredients\");","map":{"version":3,"sources":["E:/App Development/React/react-projects/react-hooks-todo/src/components/Ingredients/Ingredients.js"],"names":["React","useReducer","useEffect","useCallback","useMemo","IngredientForm","Search","IngredientList","ErrorModal","ingredientReducer","currentIngredients","action","type","ingredients","ingredient","filter","ing","id","Error","Ingredients","userIngredients","dispatch","httpState","dispatchHttp","httpReducer","isLoading","error","console","log","filterIngredientsHandler","filterIngredients","addIngredientHandler","fetch","method","body","JSON","stringify","headers","then","response","json","responseData","name","removeIngredientHandler","ingredientId","catch","errorMessage","clearError","ingredientList"],"mappings":"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","sourcesContent":["import React, { useReducer, useEffect, useCallback, useMemo } from 'react';\n\nimport IngredientForm from './IngredientForm';\nimport Search from './Search';\nimport IngredientList from './IngredientList';\nimport ErrorModal from '../UI/ErrorModal';\n\n//reducer takes in 2 arguments, the old state and an action\nconst ingredientReducer = (currentIngredients, action) => {\n  switch (action.type) {\n    case 'SET':\n      return action.ingredients; //our new ingredients, SET should override current ingredients with a new list/array. Hence the ingredients property which should be an array of ingredients which will replace the old state\n    case 'ADD':\n      return [...currentIngredients, action.ingredient];\n    case 'DELETE':\n      return currentIngredients.filter(ing => ing.id !== action.id);\n    default:\n      throw new Error('Should not get here');\n  }\n}\n\n\n\n//useCallback allows you to wrap a function that takes in two arguments, it caches your function for you so it survives rerender cycles\n// Line 21 when user submits a form on ingredients form, it will pass up the value to addIngredientHandler\nconst Ingredients = () => {\n  //useReducer returns something, that something is an array but with state (userIngredients). Second argument is something to set our userIngredients, \n  //which we are using in our reducer function (ingredientReducer)\n  //we'll call it dispatch because dispatch will be a function that call to dispatch these actions later in ingredientReducer.\n  //userReducer takes a first argument our reducer function and takes an optional second argument, starting state which we will set an an empty array\n  const [userIngredients, dispatch] = useReducer(ingredientReducer, []);\n  // const [userIngredients, setUserIngredients] = useState([]);\n  const [httpState, dispatchHttp] = useReducer(httpReducer, { isLoading: false, error: null });\n  // const [isLoading, setIsLoading] = useState(false);\n  // const [error, setError] = useState();\n\n  useEffect(() => {\n    console.log('RENDERING INGREDIENTS', userIngredients);\n  }, [userIngredients]);\n\n  //connect to search component, so when the user uses the filter/useEffect, it sends the data to this method\n  const filterIngredientsHandler = useCallback(filterIngredients => {\n    //dispatch an action, which can be anything but often its an object with a type property describing what action we want to do. And it needs an ingredients property to work properly\n    //with this we're updating our userIngredients\n    dispatch({type: 'SET', ingredients: filterIngredients})\n  }, []);\n\n  //set user ingredient should now have a id, title, and amount object\n  //user adds an ingredient, it will update the ingredients array on line 10 then to 25\n  const addIngredientHandler = useCallback(ingredient => {\n    dispatchHttp({type: 'SEND'});\n    // setIsLoading(true);\n    console.log(\"ingredient: \", ingredient);\n    //send HTTP request, browser function, not a react function\n    //fetch will return a promise, which will resolve once this request is successfully sent or fails\n    fetch('https://react-hooks-update-77b76-default-rtdb.firebaseio.com/ingredients.json', {\n      method: 'POST',\n      body: JSON.stringify({ingredient}),\n      headers: { 'Content-Type': 'application/json' }\n    }).then(response => {\n        //execute after response\n        dispatchHttp({type: 'RESPONSE'});\n        // setIsLoading(false);\n      return response.json(); //body of the response, will convert JSON to normal JS code. This returns a promise so we should return it then run another then function.\n    }).then (responseData => {\n      //only set the ingredien when the request is done as well as when the response parsing is finished\n      // setUserIngredients(previousIngredient => [...previousIngredient,\n      //   { id:responseData.name, ...ingredient }]);  \n      dispatch({type: 'ADD', ingredient: { id:responseData.name, ...ingredient }})\n        //response.name is a unique id generated by firebase, name will be different for other APIs\n    });\n  }, []);\n\n  const removeIngredientHandler = useCallback(ingredientId => {\n    console.log('removeIngredient: ', ingredientId);\n    dispatchHttp({type: 'SEND'});\n    // setIsLoading(true);\n    fetch(\n      `https://react-hooks-update-77b76-default-rtdb.firebaseio.com/ingredients/${ingredientId}.json`, \n      {\n        method: 'DELETE',\n      }\n    ).then(response => {\n      dispatchHttp({type: 'RESPONSE'});\n      // setIsLoading(false);\n      // setUserIngredients(previousIngredient => {\n      //   previousIngredient.filter(ingredient => ingredient.id !== ingredientId);\n      // });\n      dispatch({ type: 'DELETE', id: ingredientId});\n    }).catch(error => {\n      dispatchHttp({type: 'ERROR', errorMessage: 'Something went wrong'});\n      // setError(error.message);\n      // setIsLoading(false);\n    });\n  }, []);\n\n  const clearError= useCallback(() => {\n    dispatchHttp({type: 'CLEAR'});\n    // setError(null); \n  }, []);\n  \n  const ingredientList = useMemo(() => {\n    return (        \n      <IngredientList ingredients={userIngredients} onRemoveItem={removeIngredientHandler}/>\n    )\n  }, [userIngredients, removeIngredientHandler])\n\n  return (\n    <div className=\"App\">\n      {httpState.error && <ErrorModal onClose={clearError}>{httpState.error}</ErrorModal>}\n\n      <IngredientForm \n        onAddIngredient={addIngredientHandler} \n        loading={httpState.isLoading}/>\n\n      <section>\n        <Search onLoadIngredients={filterIngredientsHandler}/>\n        {ingredientList}\n      </section>\n    </div>\n  );\n}\n\nexport default Ingredients;\n"]},"metadata":{},"sourceType":"module"}