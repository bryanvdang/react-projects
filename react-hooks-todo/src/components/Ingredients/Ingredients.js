import React, { useState, useReducer, useEffect, useCallback } from 'react';

import IngredientForm from './IngredientForm';
import Search from './Search';
import IngredientList from './IngredientList';
import ErrorModal from '../UI/ErrorModal';

//reducer takes in 2 arguments, the old state and an action
const ingredientReducer = (currentIngredients, action) => {
  switch (action.type) {
    case 'SET':
      return action.ingredients; //our new ingredients, SET should override current ingredients with a new list/array. Hence the ingredients property which should be an array of ingredients which will replace the old state
    case 'ADD':
      return [...currentIngredients, action.ingredient];
    case 'DELETE':
      return currentIngredients.filter(ing => ing.id !== action.id);
    default:
      throw new Error('Should not get here');
  }
}

//here we're using reducer to manager our state to reflect the UI, we're not actually sending the state. Only thing we want to display is loading icon or an error
const httpReducer = (currentHttpState, action) => {
  //what 3 scenarios do you get when running an HTTP request? Hence the switch cases
  switch (action.type) {
    case 'SEND':
      return { isLoading: true, error: null };
    case 'RESPONSE':
      return { ...currentHttpState, isLoading: false };
    case 'ERROR':
      return { loading: true, error: action.errorMessage };
    case 'CLEAR':
      return { ...currentHttpState, error: null };
    default:
      throw new Error('Should not get here');
  }
}

//useCallback allows you to wrap a function that takes in two arguments, it caches your function for you so it survives rerender cycles
// Line 21 when user submits a form on ingredients form, it will pass up the value to addIngredientHandler
const Ingredients = () => {
  //useReducer returns something, that something is an array but with state (userIngredients). Second argument is something to set our userIngredients, 
  //which we are using in our reducer function (ingredientReducer)
  //we'll call it dispatch because dispatch will be a function that call to dispatch these actions later in ingredientReducer.
  //userReducer takes a first argument our reducer function and takes an optional second argument, starting state which we will set an an empty array
  const [userIngredients, dispatch] = useReducer(ingredientReducer, []);
  // const [userIngredients, setUserIngredients] = useState([]);
  const [httpState, dispatchHttp] = useReducer(httpReducer, { isLoading: false, error: null });
  // const [isLoading, setIsLoading] = useState(false);
  // const [error, setError] = useState();

  useEffect(() => {
    console.log('RENDERING INGREDIENTS', userIngredients);
  }, [userIngredients]);

  //connect to search component, so when the user uses the filter/useEffect, it sends the data to this method
  const filterIngredientsHandler = useCallback(filterIngredients => {
    //dispatch an action, which can be anything but often its an object with a type property describing what action we want to do. And it needs an ingredients property to work properly
    //with this we're updating our userIngredients
    dispatch({type: 'SET', ingredients: filterIngredients})
  }, []);

  //set user ingredient should now have a id, title, and amount object
  //user adds an ingredient, it will update the ingredients array on line 10 then to 25
  const addIngredientHandler = ingredient => {
    dispatchHttp({type: 'SEND'});
    // setIsLoading(true);
    console.log("ingredient: ", ingredient);
    //send HTTP request, browser function, not a react function
    //fetch will return a promise, which will resolve once this request is successfully sent or fails
    fetch('https://react-hooks-update-77b76-default-rtdb.firebaseio.com/ingredients.json', {
      method: 'POST',
      body: JSON.stringify({ingredient}),
      headers: { 'Content-Type': 'application/json' }
    }).then(response => {
        //execute after response
        dispatchHttp({type: 'RESPONSE'});
        // setIsLoading(false);
      return response.json(); //body of the response, will convert JSON to normal JS code. This returns a promise so we should return it then run another then function.
    }).then (responseData => {
      //only set the ingredien when the request is done as well as when the response parsing is finished
      // setUserIngredients(previousIngredient => [...previousIngredient,
      //   { id:responseData.name, ...ingredient }]);  
      dispatch({type: 'ADD', ingredient: { id:responseData.name, ...ingredient }})
        //response.name is a unique id generated by firebase, name will be different for other APIs
    });
  }

  const removeIngredient = ingredientId => {
    console.log('removeIngredient: ', ingredientId);
    dispatchHttp({type: 'SEND'});
    // setIsLoading(true);
    fetch(
      `https://react-hooks-update-77b76-default-rtdb.firebaseio.com/ingredients/${ingredientId}.json`, 
      {
        method: 'DELETE',
      }
    ).then(response => {
      dispatchHttp({type: 'RESPONSE'});
      // setIsLoading(false);
      // setUserIngredients(previousIngredient => {
      //   previousIngredient.filter(ingredient => ingredient.id !== ingredientId);
      // });
      dispatch({ type: 'DELETE', id: ingredientId});
    }).catch(error => {
      dispatchHttp({type: 'ERROR', errorMessage: 'Something went wrong'});
      // setError(error.message);
      // setIsLoading(false);
    });
  }

  const clearError= () => {
    dispatchHttp({type: 'CLEAR'});
    // setError(null); 
  }

  return (
    <div className="App">
      {httpState.error && <ErrorModal onClose={clearError}>{httpState.error}</ErrorModal>}
      <IngredientForm 
        onAddIngredient={addIngredientHandler} 
        loading={httpState.isLoading}/>
      <section>
        <Search onLoadIngredients={filterIngredientsHandler}/>
        <IngredientList ingredients={userIngredients} onRemoveItem={removeIngredient}/>
      </section>
    </div>
  );
}

export default Ingredients;
